import { ConversionDocument, ConversionStatus, Platform, SubscriptionTier, UserProfile, FileFormat } from '../types';

/**
 * MOCK FIREBASE SERVICE
 * 
 * Since we are running in a frontend-only environment for this demo,
 * this service simulates the Firebase Backend behavior described in the prompt:
 * 1. Authentication
 * 2. Firestore Writes/Reads
 * 3. Cloud Storage Uploads
 * 4. Cloud Function Triggers (via setTimeout)
 */

const MOCK_DELAY = 1500;

export const mockUser: UserProfile = {
  uid: 'user_12345',
  email: 'demo@chatexport.pro',
  displayName: 'Demo User',
  createdAt: new Date().toISOString(),
  subscription: SubscriptionTier.FREE,
  conversionCount: 12,
  preferences: {
    defaultFormat: FileFormat.PDF,
    autoDelete: false
  }
};

// Helper to create mock download URLs that actually work in browser
const createMockFileUrl = (type: 'pdf' | 'docx', filename: string) => {
  const content = `Mock content for ${filename}\nGenerated by ChatExport Pro Demo\n\nThis is a placeholder file to demonstrate the download functionality.`;
  const mime = type === 'pdf' ? 'application/pdf' : 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
  const blob = new Blob([content], { type: mime });
  return URL.createObjectURL(blob);
};

// Simulation of Firestore "conversions" collection
let mockConversions: ConversionDocument[] = [
  {
    conversionId: 'conv_1',
    userId: 'user_12345',
    originalFilename: 'legacy_billing_service.zip',
    platform: Platform.CHATGPT,
    status: ConversionStatus.COMPLETED,
    inputFile: 'uploads/user_12345/legacy_billing_service.zip',
    outputFiles: {
      pdf: createMockFileUrl('pdf', 'legacy_billing_service_report.pdf'),
      docx: createMockFileUrl('docx', 'legacy_billing_service_report.docx')
    },
    createdAt: new Date(Date.now() - 86400000).toISOString(),
    completedAt: new Date(Date.now() - 86390000).toISOString(),
    metadata: {
      messageCount: 68,
      wordCount: 3860,
      processingTime: 2400
    }
  },
  {
    conversionId: 'conv_2',
    userId: 'user_12345',
    originalFilename: 'inventory_monolith_dump.json',
    platform: Platform.UNKNOWN,
    status: ConversionStatus.FAILED,
    inputFile: 'uploads/user_12345/inventory_monolith_dump.json',
    createdAt: new Date(Date.now() - 172800000).toISOString(),
    error: "Dependency graph extraction failed due to malformed package metadata"
  }
];

export const AuthService = {
  login: async (): Promise<UserProfile> => {
    return new Promise((resolve) => {
      setTimeout(() => resolve(mockUser), MOCK_DELAY);
    });
  },
  logout: async (): Promise<void> => {
    return new Promise((resolve) => setTimeout(resolve, 500));
  }
};

export const ConversionService = {
  getConversions: async (userId: string): Promise<ConversionDocument[]> => {
    return new Promise((resolve) => {
      setTimeout(() => {
        // Sort by date desc
        const sorted = [...mockConversions].sort((a, b) => 
          new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        );
        resolve(sorted);
      }, 800);
    });
  },

  // Simulates: Upload -> Trigger Cloud Function -> Parse -> Generate -> Update DB
  uploadAndConvert: async (file: File, userId: string, onProgress: (status: ConversionStatus) => void): Promise<ConversionDocument> => {
    const newId = `conv_${Date.now()}`;
    const initialDoc: ConversionDocument = {
      conversionId: newId,
      userId,
      originalFilename: file.name,
      platform: Platform.UNKNOWN, // Will be detected by "Cloud Function"
      status: ConversionStatus.UPLOADING,
      inputFile: `uploads/${userId}/${file.name}`,
      createdAt: new Date().toISOString()
    };

    // 1. Start Upload
    onProgress(ConversionStatus.UPLOADING);
    
    return new Promise((resolve) => {
      setTimeout(() => {
        // 2. Upload Complete, "Cloud Function" triggers parsing
        onProgress(ConversionStatus.PROCESSING);
        
        // Simulate Cloud Function logic
        setTimeout(() => {
          // Detect platform based on filename for demo purposes
          let detectedPlatform = Platform.UNKNOWN;
          if (file.name.toLowerCase().includes('chatgpt')) detectedPlatform = Platform.CHATGPT;
          else if (file.name.toLowerCase().includes('claude')) detectedPlatform = Platform.CLAUDE;
          else if (file.name.toLowerCase().includes('grok')) detectedPlatform = Platform.GROK;
          else detectedPlatform = Platform.CHATGPT; // Default for demo

          const completedDoc: ConversionDocument = {
            ...initialDoc,
            platform: detectedPlatform,
            status: ConversionStatus.COMPLETED,
            completedAt: new Date().toISOString(),
            outputFiles: {
              pdf: createMockFileUrl('pdf', `${newId}.pdf`),
              docx: createMockFileUrl('docx', `${newId}.docx`)
            },
            metadata: {
              messageCount: Math.floor(Math.random() * 100) + 10,
              wordCount: Math.floor(Math.random() * 5000) + 500,
              processingTime: 1500 + Math.random() * 2000
            }
          };

          // Add to local mock DB
          mockConversions = [completedDoc, ...mockConversions];
          
          resolve(completedDoc);
        }, 3000); // Simulate processing time (parsing + PDF gen)
        
      }, 1500); // Simulate upload time
    });
  },

  // New method to handle URL-based imports (e.g. repository links)
  convertFromUrl: async (url: string, userId: string, onProgress: (status: ConversionStatus) => void): Promise<ConversionDocument> => {
    const newId = `conv_url_${Date.now()}`;
    
    // Auto-detect platform from URL
    let platform = Platform.UNKNOWN;
    if (url.includes('github.com')) platform = Platform.UNKNOWN;

    const initialDoc: ConversionDocument = {
      conversionId: newId,
      userId,
      originalFilename: url.length > 30 ? url.substring(0, 27) + '...' : url,
      platform,
      status: ConversionStatus.PROCESSING,
      inputFile: url,
      createdAt: new Date().toISOString()
    };

    onProgress(ConversionStatus.PROCESSING);

    return new Promise((resolve) => {
      // Simulate fetching and processing time
      setTimeout(() => {
        const completedDoc: ConversionDocument = {
          ...initialDoc,
          status: ConversionStatus.COMPLETED,
          completedAt: new Date().toISOString(),
          outputFiles: {
            pdf: createMockFileUrl('pdf', `${newId}.pdf`),
            docx: createMockFileUrl('docx', `${newId}.docx`)
          },
          metadata: {
            messageCount: Math.floor(Math.random() * 50) + 5,
            wordCount: Math.floor(Math.random() * 3000) + 200,
            processingTime: 2500
          }
        };

        mockConversions = [completedDoc, ...mockConversions];
        resolve(completedDoc);
      }, 3500);
    });
  },
  
  deleteConversion: async (id: string): Promise<void> => {
      mockConversions = mockConversions.filter(c => c.conversionId !== id);
      return Promise.resolve();
  }
};
